
# ðŸŒŸ Episode 13: Writing Test Cases and Developer Testing ðŸ§ª

Welcome to Episode 13 of my React journey! In this episode, we focused on writing test cases, understanding different types of testing, and utilizing the React Testing Library. Letâ€™s dive into the key concepts and learnings! ðŸš€

## ðŸ“š Key Learnings

### Part 1: Understanding Testing in Development ðŸ”

- **Testing** is crucial in software development to ensure that applications work as expected. Different types of testing a developer can perform include:
  - **Manual Testing**: Testing the application manually to find bugs or issues.
  - **Automated Testing**: Writing code to perform tests automatically.
    - **Unit Testing**: Testing individual components in isolation to ensure they function correctly.
    - **Integration Testing**: Testing how multiple components work together. For example, testing a search feature that involves several components.
    - **End-to-End Testing**: Testing the entire application flow from the user's perspective, simulating user interactions from landing on the application to leaving it.

### Part 2: Setting Up React Testing Library and JEST âš™ï¸

- We will be using **React Testing Library** for testing our React components. It is built on top of **JEST**, a delightful JavaScript testing framework.
- **Installation Steps**:
  1. Install React Testing Library:
     ```bash
     npm install --save-dev @testing-library/react
     ```
  2. Install JEST:
     ```bash
     npm install --save-dev jest
     ```
  3. Install Babel dependencies for transpiling:
     ```bash
     npm install --save-dev @babel/preset-env @babel/preset-react
     ```
  4. Configure Babel by creating a `babel.config.js` file:
     ```javascript
     module.exports = {
       presets: ['@babel/preset-env', '@babel/preset-react'],
     };
     ```
  5. To avoid conflicts between Parcel and Babel, create a `.parcelrc` file in the root folder to disable default Babel transpilation:
     ```json
     {
       "extends": "@parcel/config-default",
       "transform": {
         "*.js": ["@parcel/transformer-babel"]
       }
     }
     ```

### Part 3: Configuring JEST ðŸ› ï¸

- To configure JEST, run the following command:
  ```bash
  npx jest --init
  ```
  - This command will prompt you with several questions to set up your testing environment, such as:
    - Would you like to use TypeScript?
    - Set up the environment (choose jsdom for browser-like testing).
    - Create a coverage report for your tests.
    - Automatically clear mock calls between tests.

- If using JEST 28 or later, install the `jest-environment-jsdom` package:
  ```bash
  npm install --save-dev jest-environment-jsdom
  ```

- **Test File Structure**:
  - Create a `__tests__` folder anywhere in your project, or name your test files with `.test.js` or `.spec.js` extensions (e.g., `Header.test.js`).

### Part 4: Writing Basic Test Cases ðŸ“

- Hereâ€™s how to write a simple test case using JEST:
```javascript
// src/components/sum.js
export const sum = (a, b) => a + b;

// __tests__/sum.test.js
import { sum } from '../src/components/sum';

test("This function should calculate the sum of two numbers", () => {
    const result = sum(2, 3);
    expect(result).toBe(5); // Assertion
});

test("This function should calculate the sum of two negative numbers", () => {
    const result = sum(-2, -3);
    expect(result).toBe(-5); // Assertion
});
```

### Part 5: Testing the Contact Us Page ðŸ“ž

- To test whether the **Contact Us** page is loading correctly, create a file named `ContactUs.test.js` in the test folder. Import the component and render it using React Testing Library.

#### Example Test Case for Contact Us Page
```javascript
import { render, screen } from '@testing-library/react';
import ContactUs from '../src/components/ContactUs';

test('renders Contact Us page', () => {
  render(<ContactUs />);
  const linkElement = screen.getByText(/Contact Us/i);
  expect(linkElement).toBeInTheDocument();
});
```

- Ensure to add `@babel/preset-react` to your `babel.config.js` file and install `@testing-library/jest-dom` for additional matchers:
```bash
npm install --save-dev @testing-library/jest-dom
```

### Part 6: Managing Miscellaneous Files ðŸ—‚ï¸

- To keep your repository clean, add a `.gitignore` file to ignore unnecessary files, such as the coverage folder generated by tests.

### Part 7: Writing Test Cases for Header Component ðŸ·ï¸

- When writing test cases for the **Header** component, you may encounter issues due to dependencies like React Router and Redux. You will need to mock these dependencies in your tests.

#### Example of Mocking Redux and Router
```javascript
import { render } from '@testing-library/react';
import { Provider } from 'react-redux';
import { MemoryRouter } from 'react-router-dom';
import Header from '../src/components/Header';
import store from '../src/utils/AppStore';

test('renders Header component', () => {
  render(
    <Provider store={store}>
      <MemoryRouter>
        <Header />
      </MemoryRouter>
    </Provider>
  );
});
```

### Part 8: Writing Test Cases for Restaurant Card Component ðŸ½ï¸

- For the **Restaurant Card** component, use mock data to test the component by passing it via props.

#### Example of Using Mock Data
```javascript
import { render, screen } from '@testing-library/react';
import RestaurantCard from '../src/components/RestaurantCard';

const mockData = {
  id: 1,
  name: 'Test Restaurant',
  rating: 4.5,
  image: 'test-image-url',
};

test('renders Restaurant Card with correct data', () => {
  render(<RestaurantCard resData={mockData} />);
  expect(screen.getByText(/Test Restaurant/i)).toBeInTheDocument();
  expect(screen.getByText(/Rating: 4.5/i)).toBeInTheDocument();
});
```

### Part 9: Moving to Integration Testing ðŸ”—

- We will now test the **Search Component** and its functionality. To do this, render the body component and mock the fetch function since it is a browser API.

#### Example of Mocking Fetch
```javascript
global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve(mockSearchResults),
  })
);

test('search functionality works', async () => {
  render(<SearchComponent />);
  // Simulate user actions and assertions
});
```

- To run tests in watch mode, add the following script to your `package.json`:
```json
"scripts": {
  "test": "jest --watch"
}
```

- When writing async functions in tests, wrap them with the `act` function to ensure proper updates.

## ðŸŽ‰ Conclusion

In this episode, we learned how to write test cases using React Testing Library and JEST, covering unit testing, integration testing, and best practices for testing React components. Testing is an essential part of the development process, ensuring that our applications work as expected and providing a safety net for future changes. Stay tuned for the next episode! ðŸŽˆ

---

Feel free to reach out if you have any questions or want to discuss more about React and testing! Happy coding! ðŸ’»âœ¨
